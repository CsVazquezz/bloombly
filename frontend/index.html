<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GLOBE Observer Bloom Events</title>
  <style>
    body { 
      margin: 0; 
      font-family: Arial, sans-serif;
    }
    
    #globeViz { 
      width: 100vw; 
      height: 100vh; 
    }
    
    #legend {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 8px;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }
    
    .control-buttons {
      margin-bottom: 15px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .control-buttons button {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      font-size: 11px;
      transition: background-color 0.3s;
    }
    
    .control-buttons button:hover {
      background-color: #45a049;
    }
    
    .legend-item { 
      display: flex; 
      align-items: center; 
      margin-bottom: 8px; 
    }
    
    .color-box { 
      width: 15px; 
      height: 15px; 
      margin-right: 8px; 
      border-radius: 2px;
      border: 1px solid rgba(0, 0, 0, 0.2);
    }
    
    .filter-section {
      margin-bottom: 15px;
    }
    
    .filter-section h4 {
      margin: 0 0 8px 0;
      font-size: 12px;
      font-weight: bold;
    }
    
    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .checkbox-item {
      display: flex;
      align-items: center;
      font-size: 11px;
    }
    
    .checkbox-item input {
      margin-right: 5px;
    }
    
    #speciesSearch {
      width: 100%;
      padding: 5px;
      font-size: 11px;
      margin-bottom: 8px;
      border: 1px solid #ccc;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div id="globeViz"></div>
  
  <div id="legend">
    <div class="control-buttons">
      <button id="toggleCloudsBtn">Toggle Clouds</button>
      <button id="toggleRingsBtn">Toggle Rings</button>
      <button id="toggleModeBtn">Switch to Points</button>
    </div>
      <div class="filter-section">
        <h4>Data Source</h4>
        <label>
          <select id="dataSourceSelect">
            <option value="satellite">Satellite Data (Earth Engine)</option>
            <option value="prediction">ML Predictions (v2)</option>
          </select>
        </label>
        <div id="predictionOptions" style="display:none; margin-top: 8px;">
          <label>Confidence: 
            <input type="number" id="confidenceInput" min="0" max="1" step="0.1" value="0.5" style="width: 60px;">
          </label>
        </div>
      </div>
      <div class="filter-section">
        <h4>Area of Interest (AOI)</h4>
        <label>Type:
          <select id="aoiTypeSelect">
            <option value="global">Global</option>
            <option value="country">Country</option>
            <option value="state">State</option>
          </select>
        </label>
        <label>Country: <input type="text" id="aoiCountryInput" placeholder="e.g. United States, Mexico"></label>
        <label>State: <input type="text" id="aoiStateInput" placeholder="e.g. Texas"></label>
        <label>Date: <input type="date" id="dateInput" value="2024-09-15"></label>
        <button id="applyAoiBtn">Apply AOI</button>
      </div>
    <div id="filters">
      <div class="filter-section">
        <h4>Filter by Season</h4>
        <div id="seasonCheckboxes"></div>
      </div>
      <div class="filter-section">
        <h4>Filter by Family</h4>
        <input type="text" id="familySearch" placeholder="Search families...">
        <div id="familyCheckboxes"></div>
      </div>
      <div class="filter-section">
        <h4>Filter by Genus</h4>
        <input type="text" id="genusSearch" placeholder="Search genus...">
        <div id="genusCheckboxes"></div>
      </div>
    </div>
    <div id="legendContent"></div>
  </div>

  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/globe.gl"></script>

  <script>
    // ============================================================================
    // CONSTANTS
    // ============================================================================
    // const GEOJSON_FILES = ['output.geojson', 'pyrus.geojson','cactacae.geojson']; // Fallback files
    const API_BASE_URL = 'http://localhost:5001/api';
    const CLOUDS_IMAGE_URL = './clouds.png';
    const EARTH_IMAGE_URL = '//cdn.jsdelivr.net/npm/three-globe/example/img/earth-blue-marble.jpg';
    const EARTH_TOPOLOGY_URL = '//cdn.jsdelivr.net/npm/three-globe/example/img/earth-topology.png';
    
    const CLOUDS_ALTITUDE = 0.004;
    const CLOUDS_ROTATION_SPEED = -0.006; // degrees per frame
    
    const HEX_POLYGON_RESOLUTION = 6;
    const HEX_POLYGON_MARGIN = 0.3;
    
    const POINT_AREA_SCALE = 0.0000005;
    const POINT_BASE_RADIUS = 0.03;
    const RING_AREA_SCALE = 0.000003;
    const RING_BASE_RADIUS = 0.3;
    const RING_PROPAGATION_SPEED = 0.1;
    const RING_REPEAT_PERIOD = 1000;
    
    const COLOR_MODE = {
      SEASON: 'season'
    };
    
    const DISPLAY_MODE = {
      HEX: 'hex',
      POINTS: 'points'
    };
    
    const SEASON_COLORS = {
      'Spring': '#ff00ff',
      'Summer': '#ff0000',
      'Fall': '#ffa500',
      'Winter': '#0000ff'
    };
    
    const DEFAULT_COLOR = '#ff7800';
    
    const INITIAL_VIEW = {
      lat: 37,
      lng: -95,
      altitude: 2
    };

    // ============================================================================
    // STATE
    // ============================================================================
    const state = {
      geojsonFeatures: [],
      pointsData: [],
      currentColorMode: COLOR_MODE.SEASON,
      currentDisplayMode: DISPLAY_MODE.HEX,
      cloudsMesh: null,
      ringsEnabled: true,
      allFamilies: new Set(),
      allGenus: new Set(),
      selectedSeasons: new Set(['Spring', 'Summer', 'Fall', 'Winter']),
      selectedFamilies: new Set(),
      selectedGenus: new Set(),
      filteredFeatures: [],
      filteredPoints: []
    };

    // ============================================================================
    // GLOBE INITIALIZATION
    // ============================================================================
    const globe = new Globe(document.getElementById('globeViz'), { animateIn: false })
      .globeImageUrl(EARTH_IMAGE_URL)
      .bumpImageUrl(EARTH_TOPOLOGY_URL)
      .pointOfView(INITIAL_VIEW)
      .hexPolygonsData([])
      .hexPolygonResolution(HEX_POLYGON_RESOLUTION)
      .hexPolygonMargin(HEX_POLYGON_MARGIN)
      .hexPolygonUseDots(true)
      .hexPolygonColor(polygon => getColorForFeature(polygon.properties))
      .hexPolygonLabel(createHexPolygonLabel)
      .pointsData([])
      .pointColor(getColorForFeature)
      .pointRadius(calculatePointRadius)
      .pointAltitude(0)
      .ringsData([])
      .ringColor(getColorForFeature)
      .ringMaxRadius('maxR')
      .ringPropagationSpeed('propagationSpeed')
      .ringRepeatPeriod('repeatPeriod');

    // Configure controls
    globe.controls().autoRotate = false;
    globe.controls().autoRotateSpeed = 0.35;

    // ============================================================================
    // COLOR FUNCTIONS
    // ============================================================================
    function getColorForFeature(feature) {
      if (state.currentColorMode === COLOR_MODE.SEASON) {
        return SEASON_COLORS[feature.Season] || DEFAULT_COLOR;
      }
      return DEFAULT_COLOR;
    }

    // ============================================================================
    // CALCULATION FUNCTIONS
    // ============================================================================
    function calculatePointRadius(point) {
      return point.Area * POINT_AREA_SCALE + POINT_BASE_RADIUS;
    }
    
    function calculatePolygonCenter(coordinates) {
      // Take first polygon's first ring
      const ring = coordinates[0][0];
      let latSum = 0;
      let lngSum = 0;
      
      ring.forEach(coord => {
        lngSum += coord[0];
        latSum += coord[1];
      });
      
      const count = ring.length;
      return {
        lat: latSum / count,
        lng: lngSum / count
      };
    }
    
    function createPointFromFeature(feature) {
      const center = calculatePolygonCenter(feature.geometry.coordinates);
      const properties = feature.properties;
      
      return {
        lat: center.lat,
        lng: center.lng,
        Site: properties.Site,
        Family: properties.Family,
        Genus: properties.Genus,
        Season: properties.Season,
        Area: properties.Area,
        maxR: properties.Area * RING_AREA_SCALE + RING_BASE_RADIUS,
        propagationSpeed: RING_PROPAGATION_SPEED,
        repeatPeriod: RING_REPEAT_PERIOD
      };
    }

    // ============================================================================
    // UI FUNCTIONS
    // ============================================================================
    function createHexPolygonLabel({ properties: data }) {
      return `
        <b>${data.Site}</b><br/>
        Family: <i>${data.Family}</i><br/>
        Genus: <i>${data.Genus}</i><br/>
        Season: <i>${data.Season}</i><br/>
        Area: <i>${data.Area}</i>
      `;
    }
    
    function updateLegend() {
      const legendContent = document.getElementById('legendContent');
      
      if (state.currentColorMode === COLOR_MODE.SEASON) {
        legendContent.innerHTML = `
          <div class="legend-item">
            <div class="color-box" style="background-color: ${SEASON_COLORS['Spring']};"></div>
            <span>Spring</span>
          </div>
          <div class="legend-item">
            <div class="color-box" style="background-color: ${SEASON_COLORS['Summer']};"></div>
            <span>Summer</span>
          </div>
          <div class="legend-item">
            <div class="color-box" style="background-color: ${SEASON_COLORS['Fall']};"></div>
            <span>Fall</span>
          </div>
          <div class="legend-item">
            <div class="color-box" style="background-color: ${SEASON_COLORS['Winter']};"></div>
            <span>Winter</span>
          </div>
        `;
      }
    }

    function createFilterUI() {
      // Season checkboxes
      const seasonCheckboxes = document.getElementById('seasonCheckboxes');
      const seasons = ['Spring', 'Summer', 'Fall', 'Winter'];
      seasonCheckboxes.innerHTML = seasons.map(season => `
        <label class="checkbox-item">
          <input type="checkbox" value="${season}" ${state.selectedSeasons.has(season) ? 'checked' : ''}>
          ${season}
        </label>
      `).join('');
      
      // Family checkboxes
      updateFamilyCheckboxes();
      
      // Genus checkboxes
      updateGenusCheckboxes();
    }
    
    function updateFamilyCheckboxes(searchTerm = '') {
      const familyCheckboxes = document.getElementById('familyCheckboxes');
      const filteredFamilies = Array.from(state.allFamilies).filter(family => 
        family.toLowerCase().includes(searchTerm.toLowerCase())
      );
      familyCheckboxes.innerHTML = filteredFamilies.map(family => `
        <label class="checkbox-item">
          <input type="checkbox" value="${family}" ${state.selectedFamilies.has(family) ? 'checked' : ''}>
          ${family}
        </label>
      `).join('');
    }
    
    function updateGenusCheckboxes(searchTerm = '') {
      const genusCheckboxes = document.getElementById('genusCheckboxes');
      const filteredGenus = Array.from(state.allGenus).filter(genus => 
        genus.toLowerCase().includes(searchTerm.toLowerCase())
      );
      genusCheckboxes.innerHTML = filteredGenus.map(genus => `
        <label class="checkbox-item">
          <input type="checkbox" value="${genus}" ${state.selectedGenus.has(genus) ? 'checked' : ''}>
          ${genus}
        </label>
      `).join('');
    }

    // ============================================================================
    // DISPLAY MODE FUNCTIONS
    // ============================================================================
    function switchToHexMode() {
      globe.hexPolygonsData(state.filteredFeatures);
      globe.pointsData([]);
      globe.ringsData([]);
      document.getElementById('toggleModeBtn').textContent = 'Switch to Points';
    }
    
    function switchToPointsMode() {
      globe.pointsData(state.filteredPoints);
      globe.hexPolygonsData([]);
      globe.ringsData(state.ringsEnabled ? state.filteredPoints : []);
      document.getElementById('toggleModeBtn').textContent = 'Switch to Hex Polygons';
    }
    
    function refreshGlobeColors() {
      // Force update by resetting data
      globe.hexPolygonsData(globe.hexPolygonsData());
      globe.pointsData(globe.pointsData());
      globe.ringsData(globe.ringsData());
    }

    // ============================================================================
    // CLOUDS FUNCTIONS
    // ============================================================================
    function initializeClouds() {
      new THREE.TextureLoader().load(CLOUDS_IMAGE_URL, cloudsTexture => {
        const cloudsGeometry = new THREE.SphereGeometry(
          globe.getGlobeRadius() * (1 + CLOUDS_ALTITUDE), 
          75, 
          75
        );
        const cloudsMaterial = new THREE.MeshPhongMaterial({ 
          map: cloudsTexture, 
          transparent: true 
        });
        
        state.cloudsMesh = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
        globe.scene().add(state.cloudsMesh);
        
        animateClouds();
      });
    }
    
    function animateClouds() {
      if (state.cloudsMesh) {
        state.cloudsMesh.rotation.y += CLOUDS_ROTATION_SPEED * Math.PI / 180;
      }
      requestAnimationFrame(animateClouds);
    }
    
    function toggleCloudsVisibility() {
      if (!state.cloudsMesh) return;
      
      const scene = globe.scene();
      if (scene.children.includes(state.cloudsMesh)) {
        scene.remove(state.cloudsMesh);
      } else {
        scene.add(state.cloudsMesh);
      }
    }

    // ============================================================================
    // DATA LOADING
    // ============================================================================
    function loadGeoJSONData() {
      // Fetch bloom data from API (default to satellite data)
      fetch(`${API_BASE_URL}/data/blooms?aoi_type=global&date=2024-09-15`)
        .then(response => response.json())
        .then(data => {
          const allFeatures = data.features.filter(feature => 
            feature.properties.Family && feature.properties.Genus && feature.properties.Season
          );
          state.geojsonFeatures = allFeatures;
          state.pointsData = allFeatures.map(createPointFromFeature);
          
          // Populate all families and genus
          state.allFamilies = new Set(allFeatures.map(f => f.properties.Family));
          state.allGenus = new Set(allFeatures.map(f => f.properties.Genus));
          state.selectedFamilies = new Set(state.allFamilies);
          state.selectedGenus = new Set(state.allGenus);
          
          // Initial filter
          applyFilters();
          
          createFilterUI();
          updateLegend();
        })
        .catch(error => {
          console.error('Error loading bloom data from API:', error);
          // Fallback to static files if API fails
          console.log('Falling back to static GeoJSON files...');
          loadStaticGeoJSON();
        });
    }

    function loadStaticGeoJSON() {
      Promise.all(GEOJSON_FILES.map(file => fetch(file).then(response => response.json())))
        .then(datas => {
          const allFeatures = datas.flatMap(data => data.features).filter(feature => 
            feature.properties.Family && feature.properties.Genus && feature.properties.Season
          );
          state.geojsonFeatures = allFeatures;
          state.pointsData = allFeatures.map(createPointFromFeature);
          
          // Populate all families and genus
          state.allFamilies = new Set(allFeatures.map(f => f.properties.Family));
          state.allGenus = new Set(allFeatures.map(f => f.properties.Genus));
          state.selectedFamilies = new Set(state.allFamilies);
          state.selectedGenus = new Set(state.allGenus);
          
          // Initial filter
          applyFilters();
          
          createFilterUI();
          updateLegend();
        })
        .catch(error => {
          console.error('Error loading GeoJSON data:', error);
        });
    }

    // ============================================================================
    // FILTERING FUNCTIONS
    // ============================================================================
    function applyFilters() {
      state.filteredFeatures = state.geojsonFeatures.filter(feature => {
        const season = feature.properties.Season;
        const family = feature.properties.Family;
        const genus = feature.properties.Genus;
        return state.selectedSeasons.has(season) && state.selectedFamilies.has(family) && state.selectedGenus.has(genus);
      });
      state.filteredPoints = state.pointsData.filter(point => {
        const season = point.Season;
        const family = point.Family;
        const genus = point.Genus;
        return state.selectedSeasons.has(season) && state.selectedFamilies.has(family) && state.selectedGenus.has(genus);
      });
      
      // Update display
      if (state.currentDisplayMode === DISPLAY_MODE.HEX) {
        switchToHexMode();
      } else {
        switchToPointsMode();
      }
    }

    // ============================================================================
    // EVENT HANDLERS
    // ============================================================================
    function handleSeasonCheckboxChange(event) {
      const season = event.target.value;
      if (event.target.checked) {
        state.selectedSeasons.add(season);
      } else {
        state.selectedSeasons.delete(season);
      }
      applyFilters();
    }
    
    function handleFamilyCheckboxChange(event) {
      const family = event.target.value;
      if (event.target.checked) {
        state.selectedFamilies.add(family);
      } else {
        state.selectedFamilies.delete(family);
      }
      applyFilters();
    }
    
    function handleGenusCheckboxChange(event) {
      const genus = event.target.value;
      if (event.target.checked) {
        state.selectedGenus.add(genus);
      } else {
        state.selectedGenus.delete(genus);
      }
      applyFilters();
    }
    
    function handleFamilySearch(event) {
      updateFamilyCheckboxes(event.target.value);
    }
    
    function handleGenusSearch(event) {
      updateGenusCheckboxes(event.target.value);
    }
    
    function handleToggleModeClick() {
      if (state.currentDisplayMode === DISPLAY_MODE.HEX) {
        state.currentDisplayMode = DISPLAY_MODE.POINTS;
        switchToPointsMode();
      } else {
        state.currentDisplayMode = DISPLAY_MODE.HEX;
        switchToHexMode();
      }
      refreshGlobeColors();
    }
    
    function handleToggleRingsClick() {
      state.ringsEnabled = !state.ringsEnabled;
      if (state.currentDisplayMode === DISPLAY_MODE.POINTS) {
        globe.ringsData(state.ringsEnabled ? state.filteredPoints : []);
        refreshGlobeColors();
      }
    }

    // ============================================================================
    // EVENT LISTENERS
    // ============================================================================
    document.getElementById('toggleCloudsBtn').addEventListener('click', toggleCloudsVisibility);
    document.getElementById('toggleRingsBtn').addEventListener('click', handleToggleRingsClick);
    document.getElementById('toggleModeBtn').addEventListener('click', handleToggleModeClick);
    
    // Data source selection
    document.getElementById('dataSourceSelect').addEventListener('change', function(e) {
      const predictionOptions = document.getElementById('predictionOptions');
      predictionOptions.style.display = e.target.value === 'prediction' ? 'block' : 'none';
    });
    
    // Filter listeners
    document.getElementById('seasonCheckboxes').addEventListener('change', handleSeasonCheckboxChange);
    document.getElementById('familyCheckboxes').addEventListener('change', handleFamilyCheckboxChange);
    document.getElementById('genusCheckboxes').addEventListener('change', handleGenusCheckboxChange);
    document.getElementById('familySearch').addEventListener('input', handleFamilySearch);
    document.getElementById('genusSearch').addEventListener('input', handleGenusSearch);
    document.getElementById('applyAoiBtn').addEventListener('click', function() {
      const aoiType = document.getElementById('aoiTypeSelect').value;
      const aoiCountry = document.getElementById('aoiCountryInput').value.trim();
      const aoiState = document.getElementById('aoiStateInput').value.trim();
      const date = document.getElementById('dateInput').value;
      const dataSource = document.getElementById('dataSourceSelect').value;
      const confidence = document.getElementById('confidenceInput').value;

      console.log('AOI Button clicked:', { aoiType, aoiCountry, aoiState, date, dataSource });

      // Build query string
      const params = {
        aoi_type: aoiType,
        date: date
      };
      
      if (aoiCountry) params.aoi_country = aoiCountry;
      if (aoiState) params.aoi_state = aoiState;
      
      // Add prediction-specific parameters
      if (dataSource === 'prediction') {
        params.method = 'v2';
        params.confidence = confidence;
      }
      
      const qs = new URLSearchParams(params).toString();
      
      // Choose endpoint based on data source
      const endpoint = dataSource === 'prediction' ? 'predict/blooms' : 'data/blooms';
      const apiUrl = `${API_BASE_URL}/${endpoint}?${qs}`;
      console.log('Fetching from:', apiUrl);

      fetch(apiUrl)
        .then(r => {
          console.log('API Response status:', r.status);
          return r.json();
        })
        .then(data => {
          console.log('API Response data:', data);
          console.log('Number of features:', data.features ? data.features.length : 0);
          console.log('Metadata:', data.metadata);

          const allFeatures = (data.features || []).filter(feature => {
            const hasProps = feature.properties && feature.properties.Family && feature.properties.Genus && feature.properties.Season;
            return hasProps;
          });

          console.log('Filtered features count:', allFeatures.length);

          state.geojsonFeatures = allFeatures;
          state.pointsData = allFeatures.map(createPointFromFeature);
          state.allFamilies = new Set(allFeatures.map(f => f.properties.Family));
          state.allGenus = new Set(allFeatures.map(f => f.properties.Genus));
          state.selectedFamilies = new Set(state.allFamilies);
          state.selectedGenus = new Set(state.allGenus);

          console.log('Updating globe with features...');
          applyFilters();
          createFilterUI();

          console.log('Globe update complete');
        })
        .catch(err => {
          console.error('AOI fetch failed:', err);
          loadStaticGeoJSON();
        });
    });

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    loadGeoJSONData();
    initializeClouds();
  </script>
</body>
</html>