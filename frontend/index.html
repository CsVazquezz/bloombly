<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GLOBE Observer Bloom Events</title>
  <style>
    body { 
      margin: 0; 
      font-family: Arial, sans-serif;
    }
    
    #globeViz { 
      width: 100vw; 
      height: 100vh; 
    }
    
    #legend {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 8px;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      max-height: 90vh;
      overflow-y: auto;
      max-width: 250px;
    }
    
    .control-buttons {
      margin-bottom: 15px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .control-buttons button {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      font-size: 11px;
      transition: background-color 0.3s;
    }
    
    .control-buttons button:hover {
      background-color: #45a049;
    }
    
    .legend-item { 
      display: flex; 
      align-items: center; 
      margin-bottom: 8px; 
    }
    
    .color-box { 
      width: 15px; 
      height: 15px; 
      margin-right: 8px; 
      border-radius: 2px;
      border: 1px solid rgba(0, 0, 0, 0.2);
    }
    
    .filter-section {
      margin-bottom: 15px;
    }
    
    .filter-section h4 {
      margin: 0 0 8px 0;
      font-size: 12px;
      font-weight: bold;
    }
    
    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #ddd;
      padding: 5px;
      border-radius: 3px;
      background: white;
    }
    
    .checkbox-item {
      display: flex;
      align-items: center;
      font-size: 11px;
    }
    
    .checkbox-item input {
      margin-right: 5px;
    }
    
    #speciesSearch {
      width: 100%;
      padding: 5px;
      font-size: 11px;
      margin-bottom: 8px;
      border: 1px solid #ccc;
      border-radius: 3px;
    }
    
    /* Timeline styles */
    #timeline {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
    }
    
    #timelineLabel {
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 15px;
      color: #333;
    }
    
    #timelineLabel .year {
      color: #2196F3;
    }
    
    #timelineLabel .season {
      color: #4CAF50;
      margin-left: 10px;
    }
    
    #timelineControls {
      display: flex;
      align-items: center;
      gap: 15px;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    #timelineSlider {
      flex: 1;
      height: 8px;
      -webkit-appearance: none;
      appearance: none;
      background: linear-gradient(to right, #e0e0e0, #2196F3);
      outline: none;
      border-radius: 4px;
    }
    
    #timelineSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #2196F3;
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    #timelineSlider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #2196F3;
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      border: none;
    }
    
    .timeline-btn {
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      background-color: #2196F3;
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s;
      min-width: 80px;
    }
    
    .timeline-btn:hover {
      background-color: #1976D2;
    }
    
    .timeline-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    
    #playPauseBtn {
      min-width: 100px;
      background-color: #4CAF50;
    }
    
    #playPauseBtn:hover {
      background-color: #45a049;
    }
  </style>
</head>
<body>
  <div id="globeViz"></div>
  
  <div id="legend">
    <div class="control-buttons">
      <button id="toggleCloudsBtn">Toggle Clouds</button>
      <button id="toggleRingsBtn">Toggle Rings</button>
      <button id="toggleModeBtn">Switch to Points</button>
      <button id="toggleColorBtn">Color by Family</button>
    </div>
    
    <!-- Family Filter -->
    <div class="filter-section">
      <h4>Filter by Family</h4>
      <input type="text" id="familySearch" placeholder="Search families...">
      <div class="checkbox-group" id="familyCheckboxes"></div>
    </div>
    
    <!-- Genus/Species Filter -->
    <div class="filter-section">
      <h4>Filter by Genus (Species)</h4>
      <input type="text" id="speciesSearch" placeholder="Search genus...">
      <div class="checkbox-group" id="genusCheckboxes"></div>
    </div>
    
    <div id="legendContent"></div>
  </div>
  
  <!-- Timeline Bar -->
  <div id="timeline">
    <div id="timelineLabel">
      <span class="year">Year: <span id="currentYear">2000</span></span>
      <span class="season">Season: <span id="currentSeason">Spring</span></span>
    </div>
    <div id="timelineControls">
      <button class="timeline-btn" id="prevBtn">◀ Previous</button>
      <button class="timeline-btn" id="playPauseBtn">▶ Play</button>
      <input type="range" id="timelineSlider" min="0" max="100" value="0">
      <button class="timeline-btn" id="nextBtn">Next ▶</button>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/globe.gl"></script>

  <script>
    // ============================================================================
    // CONSTANTS
    // ============================================================================
    const GEOJSON_FILES = ['../data/geojson/flowering_sites.geojson'];
    const CLOUDS_IMAGE_URL = './clouds.png';
    const EARTH_IMAGE_URL = '//cdn.jsdelivr.net/npm/three-globe/example/img/earth-blue-marble.jpg';
    const EARTH_TOPOLOGY_URL = '//cdn.jsdelivr.net/npm/three-globe/example/img/earth-topology.png';
    
    const CLOUDS_ALTITUDE = 0.004;
    const CLOUDS_ROTATION_SPEED = -0.006; // degrees per frame
    
    const HEX_POLYGON_RESOLUTION = 5;
    const HEX_POLYGON_MARGIN = 0.3;
    
    const POINT_AREA_SCALE = 0.0000005;
    const POINT_BASE_RADIUS = 0.1;
    const RING_AREA_SCALE = 0.000003;
    const RING_BASE_RADIUS = 0.3;
    const RING_PROPAGATION_SPEED = 0.5;
    const RING_REPEAT_PERIOD = 500;
    
    const COLOR_MODE = {
      DEFAULT: 'default',
      FAMILY: 'family'
    };
    
    const DISPLAY_MODE = {
      HEX: 'hex',
      POINTS: 'points'
    };
    
    // Dynamic family colors - will be populated on load
    const FAMILY_COLORS = {};
    
    const DEFAULT_COLOR = '#ffff00';  // Yellow
    
    const INITIAL_VIEW = {
      lat: 37,
      lng: -95,
      altitude: 2
    };

    // ============================================================================
    // STATE
    // ============================================================================
    const state = {
      geojsonFeatures: [],
      pointsData: [],
      currentColorMode: COLOR_MODE.DEFAULT,
      currentDisplayMode: DISPLAY_MODE.POINTS,
      cloudsMesh: null,
      ringsEnabled: false,
      allFamilies: new Set(),
      allGenus: new Set(),
      genusToFamily: new Map(), // Maps genus -> family
      selectedFamilies: new Set(),
      selectedGenus: new Set(),
      allYears: [],
      timelineSteps: [],
      currentTimelineIndex: 0,
      isPlaying: false,
      playInterval: null,
      filteredFeatures: [],
      filteredPoints: []
    };

    // ============================================================================
    // GLOBE INITIALIZATION
    // ============================================================================
    const globe = new Globe(document.getElementById('globeViz'), { animateIn: false })
      .globeImageUrl(EARTH_IMAGE_URL)
      .bumpImageUrl(EARTH_TOPOLOGY_URL)
      .pointOfView(INITIAL_VIEW)
      .hexPolygonsData([])
      .hexPolygonResolution(HEX_POLYGON_RESOLUTION)
      .hexPolygonMargin(HEX_POLYGON_MARGIN)
      .hexPolygonUseDots(true)
      .hexPolygonColor(polygon => getColorForFeature(polygon.properties))
      .hexPolygonLabel(createHexPolygonLabel)
      .pointsData([])
      .pointColor(getColorForFeature)
      .pointRadius(calculatePointRadius)
      .pointAltitude(0)
      .ringsData([])
      .ringColor(getColorForFeature)
      .ringMaxRadius('maxR')
      .ringPropagationSpeed('propagationSpeed')
      .ringRepeatPeriod('repeatPeriod');

    // Configure controls
    globe.controls().autoRotate = false;
    globe.controls().autoRotateSpeed = 0.35;

    // ============================================================================
    // COLOR FUNCTIONS
    // ============================================================================
    function generateColorForFamily(family, index, total) {
      // Generate distinct colors using HSL color space
      const hue = (index * 360 / total) % 360;
      const saturation = 70 + (index % 3) * 10; // 70-90%
      const lightness = 50 + (index % 2) * 10; // 50-60%
      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }
    
    function initializeFamilyColors() {
      const allFamiliesArray = Array.from(state.allFamilies).sort();
      allFamiliesArray.forEach((family, index) => {
        FAMILY_COLORS[family] = generateColorForFamily(family, index, allFamiliesArray.length);
      });
    }
    
    function getColorForFeature(feature) {
      if (state.currentColorMode === COLOR_MODE.FAMILY) {
        return FAMILY_COLORS[feature.Family] || DEFAULT_COLOR;
      }
      // Default mode - all flowers same color
      return DEFAULT_COLOR;
    }

    // ============================================================================
    // CALCULATION FUNCTIONS
    // ============================================================================
    function calculatePointRadius(point) {
      return point.Area * POINT_AREA_SCALE + POINT_BASE_RADIUS;
    }
    
    function calculatePolygonCenter(coordinates) {
      // Take first polygon's first ring
      const ring = coordinates[0][0];
      let latSum = 0;
      let lngSum = 0;
      
      ring.forEach(coord => {
        lngSum += coord[0];
        latSum += coord[1];
      });
      
      const count = ring.length;
      return {
        lat: latSum / count,
        lng: lngSum / count
      };
    }
    
    function createPointFromFeature(feature) {
      const center = calculatePolygonCenter(feature.geometry.coordinates);
      const properties = feature.properties;
      
      return {
        lat: center.lat,
        lng: center.lng,
        Site: `${properties.Family} - ${properties.Genus}`,
        Family: properties.Family,
        Genus: properties.Genus,
        Season: properties.Season,
        Area: properties.Area,
        year: properties.year,
        maxR: properties.Area * RING_AREA_SCALE + RING_BASE_RADIUS,
        propagationSpeed: RING_PROPAGATION_SPEED,
        repeatPeriod: RING_REPEAT_PERIOD
      };
    }

    // ============================================================================
    // UI FUNCTIONS
    // ============================================================================
    function createHexPolygonLabel({ properties: data }) {
      return `
        <b>${data.Family} - ${data.Genus}</b><br/>
        Season: <i>${data.Season}</i><br/>
        Area: <i>${data.Area.toFixed(2)} km²</i><br/>
        Year: <i>${data.year}</i>
      `;
    }
    
    function updateLegend() {
      const legendContent = document.getElementById('legendContent');
      
      if (state.currentColorMode === COLOR_MODE.FAMILY) {
        // Show all families in legend
        const familyCounts = {};
        state.geojsonFeatures.forEach(f => {
          const family = f.properties.Family;
          familyCounts[family] = (familyCounts[family] || 0) + 1;
        });
        
        const sortedFamilies = Object.entries(familyCounts)
          .sort((a, b) => b[1] - a[1])
          .map(([family]) => family);
        
        let html = '<h4 style="margin: 10px 0 8px 0;">Families</h4>';
        sortedFamilies.forEach(family => {
          html += `
            <div class="legend-item">
              <div class="color-box" style="background-color: ${FAMILY_COLORS[family]};"></div>
              <span>${family}</span>
            </div>
          `;
        });
        
        legendContent.innerHTML = html;
      } else {
        // Default mode - no legend needed
        legendContent.innerHTML = '';
      }
    }

    // ============================================================================
    // TIMELINE FUNCTIONS
    // ============================================================================
    function buildTimelineSteps() {
      // Extract unique years from data
      const yearsSet = new Set(state.geojsonFeatures.map(f => f.properties.year));
      state.allYears = Array.from(yearsSet).sort((a, b) => a - b);
      
      // Create timeline steps: each year has 4 seasons
      const seasons = ['Spring', 'Summer', 'Fall', 'Winter'];
      state.timelineSteps = [];
      
      state.allYears.forEach(year => {
        seasons.forEach(season => {
          state.timelineSteps.push({ year, season });
        });
      });
      
      // Update slider max value
      const slider = document.getElementById('timelineSlider');
      slider.max = state.timelineSteps.length - 1;
      
      // Find the index for Spring 2000
      const spring2000Index = state.timelineSteps.findIndex(
        step => step.year === 2000 && step.season === 'Spring'
      );
      
      // Set initial position to Spring 2000, or 0 if not found
      state.currentTimelineIndex = spring2000Index !== -1 ? spring2000Index : 0;
      slider.value = state.currentTimelineIndex;
      
      // Set initial timeline position
      updateTimelineDisplay();
    }
    
    function updateTimelineDisplay() {
      if (state.timelineSteps.length === 0) return;
      
      const currentStep = state.timelineSteps[state.currentTimelineIndex];
      document.getElementById('currentYear').textContent = currentStep.year;
      document.getElementById('currentSeason').textContent = currentStep.season;
      
      // Update slider position
      document.getElementById('timelineSlider').value = state.currentTimelineIndex;
      
      // Update prev/next button states
      document.getElementById('prevBtn').disabled = state.currentTimelineIndex === 0;
      document.getElementById('nextBtn').disabled = state.currentTimelineIndex === state.timelineSteps.length - 1;
      
      // Filter data based on current timeline
      applyTimelineFilter();
    }
    
    function applyTimelineFilter() {
      if (state.timelineSteps.length === 0) return;
      
      const currentStep = state.timelineSteps[state.currentTimelineIndex];
      
      state.filteredFeatures = state.geojsonFeatures.filter(feature => {
        const matchesTimeline = feature.properties.year === currentStep.year && 
                                feature.properties.Season === currentStep.season;
        
        // Apply family and genus filters
        const matchesFamily = state.selectedFamilies.size === 0 || 
                             state.selectedFamilies.has(feature.properties.Family);
        const matchesGenus = state.selectedGenus.size === 0 || 
                            state.selectedGenus.has(feature.properties.Genus);
        
        return matchesTimeline && matchesFamily && matchesGenus;
      });
      
      state.filteredPoints = state.pointsData.filter(point => {
        const matchesTimeline = point.year === currentStep.year && 
                               point.Season === currentStep.season;
        
        // Apply family and genus filters
        const matchesFamily = state.selectedFamilies.size === 0 || 
                             state.selectedFamilies.has(point.Family);
        const matchesGenus = state.selectedGenus.size === 0 || 
                            state.selectedGenus.has(point.Genus);
        
        return matchesTimeline && matchesFamily && matchesGenus;
      });
      
      // Update display
      if (state.currentDisplayMode === DISPLAY_MODE.HEX) {
        switchToHexMode();
      } else {
        switchToPointsMode();
      }
    }
    
    function goToPreviousStep() {
      if (state.currentTimelineIndex > 0) {
        state.currentTimelineIndex--;
        updateTimelineDisplay();
      }
    }
    
    function goToNextStep() {
      if (state.currentTimelineIndex < state.timelineSteps.length - 1) {
        state.currentTimelineIndex++;
        updateTimelineDisplay();
      }
    }
    
    function togglePlayPause() {
      state.isPlaying = !state.isPlaying;
      const playPauseBtn = document.getElementById('playPauseBtn');
      
      if (state.isPlaying) {
        playPauseBtn.textContent = '⏸ Pause';
        state.playInterval = setInterval(() => {
          if (state.currentTimelineIndex < state.timelineSteps.length - 1) {
            goToNextStep();
          } else {
            // Loop back to start
            state.currentTimelineIndex = 0;
            updateTimelineDisplay();
          }
        }, 500); // Change every half second (2x faster)
      } else {
        playPauseBtn.textContent = '▶ Play';
        if (state.playInterval) {
          clearInterval(state.playInterval);
          state.playInterval = null;
        }
      }
    }
    
    function handleSliderChange(event) {
      state.currentTimelineIndex = parseInt(event.target.value);
      updateTimelineDisplay();
      
      // Pause if playing
      if (state.isPlaying) {
        togglePlayPause();
      }
    }

    function createFilterUI() {
      updateFamilyCheckboxes();
      updateGenusCheckboxes();
      
      // Add search listeners
      document.getElementById('familySearch').addEventListener('input', (e) => {
        updateFamilyCheckboxes(e.target.value);
      });
      
      document.getElementById('speciesSearch').addEventListener('input', (e) => {
        updateGenusCheckboxes(e.target.value);
      });
    }
    
    function updateFamilyCheckboxes(searchTerm = '') {
      const container = document.getElementById('familyCheckboxes');
      const families = Array.from(state.allFamilies).sort();
      const filteredFamilies = searchTerm 
        ? families.filter(f => f.toLowerCase().includes(searchTerm.toLowerCase()))
        : families;
      
      // Determine if a family should be checked
      // If selectedFamilies is empty, all should be checked (no filter active)
      // Otherwise, only selected ones should be checked
      const shouldBeChecked = (family) => {
        if (state.selectedFamilies.size === 0) {
          return true; // No filter active, all checked
        }
        return state.selectedFamilies.has(family);
      };
      
      container.innerHTML = filteredFamilies.map(family => `
        <label class="checkbox-item">
          <input type="checkbox" value="${family}" 
                 ${shouldBeChecked(family) ? 'checked' : ''}>
          ${family}
        </label>
      `).join('');
      
      // Add event listeners
      container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', handleFamilyFilterChange);
      });
    }
    
    function updateGenusCheckboxes(searchTerm = '') {
      const container = document.getElementById('genusCheckboxes');
      const genuses = Array.from(state.allGenus).sort();
      const filteredGenuses = searchTerm 
        ? genuses.filter(g => g.toLowerCase().includes(searchTerm.toLowerCase()))
        : genuses;
      
      // Determine if a genus should be checked
      const shouldBeChecked = (genus) => {
        if (state.selectedGenus.size === 0) {
          return true; // No filter active, all checked
        }
        return state.selectedGenus.has(genus);
      };
      
      container.innerHTML = filteredGenuses.map(genus => `
        <label class="checkbox-item">
          <input type="checkbox" value="${genus}" 
                 ${shouldBeChecked(genus) ? 'checked' : ''}>
          ${genus}
        </label>
      `).join('');
      
      // Add event listeners
      container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', handleGenusFilterChange);
      });
    }
    
    function handleFamilyFilterChange(event) {
      const changedFamily = event.target.value;
      const isChecked = event.target.checked;
      const container = document.getElementById('familyCheckboxes');
      const allCheckboxes = container.querySelectorAll('input[type="checkbox"]');
      const checkedCheckboxes = Array.from(allCheckboxes).filter(cb => cb.checked);
      
      // Clear and rebuild the selected set based on what's checked
      state.selectedFamilies.clear();
      checkedCheckboxes.forEach(cb => {
        state.selectedFamilies.add(cb.value);
      });
      
      // If all are checked, clear the set (means show all)
      if (checkedCheckboxes.length === allCheckboxes.length) {
        state.selectedFamilies.clear();
      }
      
      // CASCADE: If a family was unchecked, uncheck all its genus children
      if (!isChecked) {
        // Find all genus that belong to this family
        const genusInFamily = Array.from(state.genusToFamily.entries())
          .filter(([genus, family]) => family === changedFamily)
          .map(([genus, family]) => genus);
        
        // Remove these genus from selected set
        genusInFamily.forEach(genus => {
          state.selectedGenus.delete(genus);
        });
        
        // Update genus checkboxes to reflect the change
        const genusContainer = document.getElementById('genusCheckboxes');
        genusContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
          if (genusInFamily.includes(checkbox.value)) {
            checkbox.checked = false;
          }
        });
      }
      
      applyTimelineFilter();
    }
    
    function handleGenusFilterChange(event) {
      const genus = event.target.value;
      const container = document.getElementById('genusCheckboxes');
      const allCheckboxes = container.querySelectorAll('input[type="checkbox"]');
      const checkedCheckboxes = Array.from(allCheckboxes).filter(cb => cb.checked);
      
      // Clear and rebuild the selected set based on what's checked
      state.selectedGenus.clear();
      checkedCheckboxes.forEach(cb => {
        state.selectedGenus.add(cb.value);
      });
      
      // If all are checked, clear the set (means show all)
      if (checkedCheckboxes.length === allCheckboxes.length) {
        state.selectedGenus.clear();
      }
      
      applyTimelineFilter();
    }

    // ============================================================================
    // DISPLAY MODE FUNCTIONS
    // ============================================================================
    function switchToHexMode() {
      globe.hexPolygonsData(state.filteredFeatures);
      globe.pointsData([]);
      globe.ringsData([]);
      document.getElementById('toggleModeBtn').textContent = 'Switch to Points';
    }
    
    function switchToPointsMode() {
      globe.pointsData(state.filteredPoints);
      globe.hexPolygonsData([]);
      globe.ringsData(state.ringsEnabled ? state.filteredPoints : []);
      document.getElementById('toggleModeBtn').textContent = 'Switch to Hex Polygons';
    }
    
    function refreshGlobeColors() {
      // Force update by resetting data
      globe.hexPolygonsData(globe.hexPolygonsData());
      globe.pointsData(globe.pointsData());
      globe.ringsData(globe.ringsData());
    }

    // ============================================================================
    // CLOUDS FUNCTIONS
    // ============================================================================
    function initializeClouds() {
      new THREE.TextureLoader().load(CLOUDS_IMAGE_URL, cloudsTexture => {
        const cloudsGeometry = new THREE.SphereGeometry(
          globe.getGlobeRadius() * (1 + CLOUDS_ALTITUDE), 
          75, 
          75
        );
        const cloudsMaterial = new THREE.MeshPhongMaterial({ 
          map: cloudsTexture, 
          transparent: true 
        });
        
        state.cloudsMesh = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
        // Clouds are toggled off by default - don't add to scene initially
        // globe.scene().add(state.cloudsMesh);
        
        animateClouds();
      });
    }
    
    function animateClouds() {
      if (state.cloudsMesh) {
        state.cloudsMesh.rotation.y += CLOUDS_ROTATION_SPEED * Math.PI / 180;
      }
      requestAnimationFrame(animateClouds);
    }
    
    function toggleCloudsVisibility() {
      if (!state.cloudsMesh) return;
      
      const scene = globe.scene();
      if (scene.children.includes(state.cloudsMesh)) {
        scene.remove(state.cloudsMesh);
      } else {
        scene.add(state.cloudsMesh);
      }
    }

    // ============================================================================
    // DATA LOADING
    // ============================================================================
    function loadGeoJSONData() {
      Promise.all(GEOJSON_FILES.map(file => fetch(file).then(response => response.json())))
        .then(datas => {
          const allFeatures = datas.flatMap(data => data.features).filter(feature => 
            feature.properties.Family && feature.properties.Genus && feature.properties.Season
          );
          state.geojsonFeatures = allFeatures;
          state.pointsData = allFeatures.map(createPointFromFeature);
          
          // Populate all families and genus
          state.allFamilies = new Set(allFeatures.map(f => f.properties.Family));
          state.allGenus = new Set(allFeatures.map(f => f.properties.Genus));
          
          // Build genus to family mapping
          state.genusToFamily.clear();
          allFeatures.forEach(f => {
            state.genusToFamily.set(f.properties.Genus, f.properties.Family);
          });
          
          // Initialize family colors
          initializeFamilyColors();
          
          // Build timeline
          buildTimelineSteps();
          
          // Create filter UI
          createFilterUI();
          
          updateLegend();
          switchToPointsMode();
        })
        .catch(error => {
          console.error('Error loading GeoJSON data:', error);
          alert('Error loading data: ' + error.message);
        });
    }

    // ============================================================================
    // FILTERING FUNCTIONS (Legacy - now handled by timeline)
    // ============================================================================
    function applyFilters() {
      // Now handled by applyTimelineFilter
      applyTimelineFilter();
    }

    // ============================================================================
    // EVENT HANDLERS
    // ============================================================================
    function handleToggleModeClick() {
      if (state.currentDisplayMode === DISPLAY_MODE.HEX) {
        state.currentDisplayMode = DISPLAY_MODE.POINTS;
        switchToPointsMode();
      } else {
        state.currentDisplayMode = DISPLAY_MODE.HEX;
        switchToHexMode();
      }
      refreshGlobeColors();
    }
    
    function handleToggleRingsClick() {
      state.ringsEnabled = !state.ringsEnabled;
      if (state.currentDisplayMode === DISPLAY_MODE.POINTS) {
        globe.ringsData(state.ringsEnabled ? state.filteredPoints : []);
        refreshGlobeColors();
      }
    }
    
    function handleToggleColorClick() {
      // Toggle between default and family color modes
      if (state.currentColorMode === COLOR_MODE.DEFAULT) {
        state.currentColorMode = COLOR_MODE.FAMILY;
        document.getElementById('toggleColorBtn').textContent = 'Single Color';
      } else {
        state.currentColorMode = COLOR_MODE.DEFAULT;
        document.getElementById('toggleColorBtn').textContent = 'Color by Family';
      }
      
      // Update legend
      updateLegend();
      
      // Refresh globe colors
      refreshGlobeColors();
    }

    // ============================================================================
    // EVENT LISTENERS
    // ============================================================================
    document.getElementById('toggleCloudsBtn').addEventListener('click', toggleCloudsVisibility);
    document.getElementById('toggleRingsBtn').addEventListener('click', handleToggleRingsClick);
    document.getElementById('toggleModeBtn').addEventListener('click', handleToggleModeClick);
    document.getElementById('toggleColorBtn').addEventListener('click', handleToggleColorClick);
    
    // Timeline listeners
    document.getElementById('prevBtn').addEventListener('click', goToPreviousStep);
    document.getElementById('nextBtn').addEventListener('click', goToNextStep);
    document.getElementById('playPauseBtn').addEventListener('click', togglePlayPause);
    document.getElementById('timelineSlider').addEventListener('input', handleSliderChange);

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    loadGeoJSONData();
    initializeClouds();
  </script>
</body>
</html>