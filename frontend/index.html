<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GLOBE Observer Bloom Events</title>
  <style>
    body { 
      margin: 0; 
      font-family: Arial, sans-serif;
    }
    
    #globeViz { 
      width: 100vw; 
      height: 100vh; 
    }
    
    #legend {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 8px;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      max-height: 90vh;
      overflow-y: auto;
      max-width: 250px;
    }
    
    .control-buttons {
      margin-bottom: 15px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .control-buttons button {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      font-size: 11px;
      transition: background-color 0.3s;
    }
    
    .control-buttons button:hover {
      background-color: #45a049;
    }
    
    .legend-item { 
      display: flex; 
      align-items: center; 
      margin-bottom: 8px; 
    }
    
    .color-box { 
      width: 15px; 
      height: 15px; 
      margin-right: 8px; 
      border-radius: 2px;
      border: 1px solid rgba(0, 0, 0, 0.2);
    }
    
    .filter-section {
      margin-bottom: 15px;
    }
    
    .filter-section h4 {
      margin: 0 0 8px 0;
      font-size: 12px;
      font-weight: bold;
    }
    
    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid #ddd;
      padding: 5px;
      border-radius: 3px;
      background: white;
    }
    
    .checkbox-item {
      display: flex;
      align-items: center;
      font-size: 11px;
    }
    
    .checkbox-item input {
      margin-right: 5px;
    }
    
    #speciesSearch {
      width: 100%;
      padding: 5px;
      font-size: 11px;
      margin-bottom: 8px;
      border: 1px solid #ccc;
      border-radius: 3px;
    }
    
    #summary {
      position: absolute;
      top: 60px;
      left: 10px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px;
      border-radius: 8px;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      max-width: 350px;
      max-height: calc(80vh - 70px);
      overflow-y: auto;
      display: none;
      z-index: 999;
    }
    
    #summary h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: #2c3e50;
      border-bottom: 2px solid #4CAF50;
      padding-bottom: 5px;
    }
    
    #summary h4 {
      margin: 10px 0 5px 0;
      font-size: 12px;
      color: #34495e;
    }
    
    .summary-stat {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
      padding: 3px 0;
      border-bottom: 1px solid #ecf0f1;
    }
    
    .summary-stat .label {
      font-weight: 600;
      color: #555;
    }
    
    .summary-stat .value {
      color: #2c3e50;
    }
    
    .confidence-bar {
      display: flex;
      gap: 5px;
      margin-top: 5px;
    }
    
    .confidence-segment {
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 10px;
      text-align: center;
    }
    
    .high-confidence {
      background-color: #27ae60;
      color: white;
    }
    
    .medium-confidence {
      background-color: #f39c12;
      color: white;
    }
    
    .low-confidence {
      background-color: #95a5a6;
      color: white;
    }
    
    #toggleSummaryBtn {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(76, 175, 80, 0.9);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      z-index: 1000;
    }
    
    #toggleSummaryBtn:hover {
      background: rgba(69, 160, 73, 1);
    }
    
    /* Timeline styles */
    #timeline {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
    }
    
    #timelineLabel {
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 15px;
      color: #333;
    }
    
    #timelineLabel .year {
      color: #2196F3;
    }
    
    #timelineLabel .season {
      color: #4CAF50;
      margin-left: 10px;
    }
    
    #timelineControls {
      display: flex;
      align-items: center;
      gap: 15px;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    #timelineSlider {
      flex: 1;
      height: 8px;
      -webkit-appearance: none;
      appearance: none;
      background: linear-gradient(to right, #e0e0e0, #2196F3);
      outline: none;
      border-radius: 4px;
    }
    
    #timelineSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #2196F3;
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    #timelineSlider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #2196F3;
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      border: none;
    }
    
    .timeline-btn {
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      background-color: #2196F3;
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s;
      min-width: 80px;
    }
    
    .timeline-btn:hover {
      background-color: #1976D2;
    }
    
    .timeline-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    
    #playPauseBtn {
      min-width: 100px;
      background-color: #4CAF50;
    }
    
    #playPauseBtn:hover {
      background-color: #45a049;
    }
  </style>
</head>
<body>
  <button id="toggleSummaryBtn">Show Summary</button>
  
  <div id="summary">
    <h3>Prediction Summary</h3>
    <div id="summaryContent">
      <p style="color: #7f8c8d; font-style: italic;">Load prediction data to see summary</p>
    </div>
  </div>
  
  <div id="globeViz"></div>
  
  <div id="legend">
    <div class="control-buttons">
      <button id="toggleCloudsBtn">Toggle Clouds</button>
      <button id="toggleRingsBtn">Toggle Rings</button>
      <button id="toggleModeBtn">Switch to Points</button>
      <button id="toggleColorBtn">Color by Family</button>
    </div>
    
    <div class="filter-section">
      <h4>Data Source</h4>
      <label>
        <select id="dataSourceSelect">
          <option value="prediction" selected>ML Predictions (v2) - Recommended ⭐</option>
          <option value="satellite">Satellite Data (Earth Engine) - Slow ⚠️</option>
        </select>
      </label>
      <div id="predictionOptions" style="display:block; margin-top: 8px;">
        <label>Confidence Threshold: 
          <input type="number" id="confidenceInput" min="0" max="1" step="0.1" value="0.3" style="width: 60px;">
          <small style="color: #7f8c8d;">(0.0 - 1.0)</small>
        </label>
        <br>
        <label>Max Predictions: 
          <input type="number" id="numPredictionsInput" min="50" max="500" step="50" value="150" style="width: 60px;">
          <small style="color: #7f8c8d;">(50-500)</small>
        </label>
      </div>
    </div>
    <div class="filter-section">
      <h4>Area of Interest (AOI)</h4>
      <label>Type:
        <select id="aoiTypeSelect">
          <option value="point">Point (Lat/Lon)</option>
          <option value="state" selected>State</option>
          <option value="country">Country</option>
          <option value="global">Global</option>
        </select>
      </label>
      
      <!-- Point coordinates (for point AOI) -->
      <div id="pointCoordinates" style="display:none; margin-top: 8px;">
        <label>Latitude: <input type="number" id="latInput" min="-90" max="90" step="0.01" placeholder="e.g. 20.5" style="width: 80px;"></label>
        <label>Longitude: <input type="number" id="lonInput" min="-180" max="180" step="0.01" placeholder="e.g. -100.0" style="width: 80px;"></label>
      </div>
      
      <!-- Country selection -->
      <div id="countryOptions" style="display:none; margin-top: 8px;">
        <label>Country:
          <select id="aoiCountrySelect" style="width: 100%;">
            <option value="">Select Country</option>
            <option value="Mexico">Mexico</option>
            <option value="United States">United States</option>
          </select>
        </label>
      </div>
      
      <!-- State selection -->
      <div id="stateOptions" style="display:block; margin-top: 8px;">
        <label>Country:
          <select id="stateCountrySelect" style="width: 100%;">
            <option value="Mexico" selected>Mexico</option>
            <option value="United States">United States</option>
          </select>
        </label>
        <label>State:
          <select id="aoiStateSelect" style="width: 100%;">
            <!-- Mexican States -->
            <optgroup label="Mexican States">
              <option value="Aguascalientes">Aguascalientes</option>
              <option value="Baja California">Baja California</option>
              <option value="Baja California Sur">Baja California Sur</option>
              <option value="Campeche">Campeche</option>
              <option value="Chiapas">Chiapas</option>
              <option value="Chihuahua">Chihuahua</option>
              <option value="Coahuila">Coahuila</option>
              <option value="Colima">Colima</option>
              <option value="Durango">Durango</option>
              <option value="Guanajuato">Guanajuato</option>
              <option value="Guerrero">Guerrero</option>
              <option value="Hidalgo">Hidalgo</option>
              <option value="Jalisco">Jalisco</option>
              <option value="Mexico">Mexico</option>
              <option value="Michoacan">Michoacán</option>
              <option value="Morelos">Morelos</option>
              <option value="Nayarit">Nayarit</option>
              <option value="Nuevo Leon">Nuevo León</option>
              <option value="Oaxaca">Oaxaca</option>
              <option value="Puebla">Puebla</option>
              <option value="Queretaro" selected>Querétaro</option>
              <option value="Quintana Roo">Quintana Roo</option>
              <option value="San Luis Potosi">San Luis Potosí</option>
              <option value="Sinaloa">Sinaloa</option>
              <option value="Sonora">Sonora</option>
              <option value="Tabasco">Tabasco</option>
              <option value="Tamaulipas">Tamaulipas</option>
              <option value="Tlaxcala">Tlaxcala</option>
              <option value="Veracruz">Veracruz</option>
              <option value="Yucatan">Yucatán</option>
              <option value="Zacatecas">Zacatecas</option>
            </optgroup>
            <!-- US States (popular ones) -->
            <optgroup label="US States">
              <option value="California">California</option>
              <option value="Texas">Texas</option>
              <option value="Florida">Florida</option>
              <option value="New York">New York</option>
            </optgroup>
          </select>
        </label>
      </div>
      
      <label>Date: <input type="date" id="dateInput" value="2025-10-05"></label>
      <button id="applyAoiBtn" style="width: 100%; padding: 10px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; margin-top: 8px;">🌸 Fetch Bloom Data</button>
    </div>
    
    <div id="filters">
      <div class="filter-section">
        <h4>Filter by Season</h4>
        <div id="seasonCheckboxes"></div>
      </div>
      
      <!-- Family Filter -->
      <div class="filter-section">
        <h4>Filter by Family</h4>
        <input type="text" id="familySearch" placeholder="Search families...">
        <div class="checkbox-group" id="familyCheckboxes"></div>
      </div>
      
      <!-- Genus/Species Filter -->
      <div class="filter-section">
        <h4>Filter by Genus (Species)</h4>
        <input type="text" id="genusSearch" placeholder="Search genus...">
        <div class="checkbox-group" id="genusCheckboxes"></div>
      </div>
    </div>
    
    <div id="legendContent"></div>
  </div>
  
  <!-- Timeline Bar -->
  <div id="timeline">
    <div id="timelineLabel">
      <span class="year">Year: <span id="currentYear">2000</span></span>
      <span class="season">Season: <span id="currentSeason">Spring</span></span>
    </div>
    <div id="timelineControls">
      <button class="timeline-btn" id="prevBtn">◀ Previous</button>
      <button class="timeline-btn" id="playPauseBtn">▶ Play</button>
      <input type="range" id="timelineSlider" min="0" max="100" value="0">
      <button class="timeline-btn" id="nextBtn">Next ▶</button>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/globe.gl"></script>

  <script>
    // ============================================================================
    // CONSTANTS
    // ============================================================================
    const GEOJSON_FILES = ['../data/geojson/flowering_sites.geojson']; // Fallback files
    const API_BASE_URL = 'http://localhost:5001/api';
    const CLOUDS_IMAGE_URL = './clouds.png';
    const EARTH_IMAGE_URL = '//cdn.jsdelivr.net/npm/three-globe/example/img/earth-blue-marble.jpg';
    const EARTH_TOPOLOGY_URL = '//cdn.jsdelivr.net/npm/three-globe/example/img/earth-topology.png';
    
    const CLOUDS_ALTITUDE = 0.004;
    const CLOUDS_ROTATION_SPEED = -0.006; // degrees per frame
    
    const HEX_POLYGON_RESOLUTION = 5;
    const HEX_POLYGON_MARGIN = 0.3;
    
    const POINT_AREA_SCALE = 0.0000005;
    const POINT_BASE_RADIUS = 0.1;
    const RING_AREA_SCALE = 0.000003;
    const RING_BASE_RADIUS = 0.3;
    const RING_PROPAGATION_SPEED = 0.5;
    const RING_REPEAT_PERIOD = 500;
    
    const COLOR_MODE = {
      DEFAULT: 'default',
      FAMILY: 'family'
    };
    
    const DISPLAY_MODE = {
      HEX: 'hex',
      POINTS: 'points'
    };
    
    // Dynamic family colors - will be populated on load
    const FAMILY_COLORS = {};
    
    const DEFAULT_COLOR = '#ffff00';  // Yellow
    
    const INITIAL_VIEW = {
      lat: 37,
      lng: -95,
      altitude: 2
    };

    // ============================================================================
    // STATE
    // ============================================================================
    const state = {
      geojsonFeatures: [],
      pointsData: [],
      currentColorMode: COLOR_MODE.DEFAULT,
      currentDisplayMode: DISPLAY_MODE.POINTS,
      cloudsMesh: null,
      ringsEnabled: false,
      allFamilies: new Set(),
      allGenus: new Set(),
      genusToFamily: new Map(), // Maps genus -> family
      selectedFamilies: new Set(),
      selectedGenus: new Set(),
      allYears: [],
      timelineSteps: [],
      currentTimelineIndex: 0,
      isPlaying: false,
      playInterval: null,
      filteredFeatures: [],
      filteredPoints: []
    };

    // ============================================================================
    // GLOBE INITIALIZATION
    // ============================================================================
    const globe = new Globe(document.getElementById('globeViz'), { animateIn: false })
      .globeImageUrl(EARTH_IMAGE_URL)
      .bumpImageUrl(EARTH_TOPOLOGY_URL)
      .pointOfView(INITIAL_VIEW)
      .hexPolygonsData([])
      .hexPolygonResolution(HEX_POLYGON_RESOLUTION)
      .hexPolygonMargin(HEX_POLYGON_MARGIN)
      .hexPolygonUseDots(true)
      .hexPolygonColor(polygon => getColorForFeature(polygon.properties))
      .hexPolygonLabel(createHexPolygonLabel)
      .pointsData([])
      .pointColor(getColorForFeature)
      .pointRadius(calculatePointRadius)
      .pointAltitude(0)
      .ringsData([])
      .ringColor(getColorForFeature)
      .ringMaxRadius('maxR')
      .ringPropagationSpeed('propagationSpeed')
      .ringRepeatPeriod('repeatPeriod');

    // Configure controls
    globe.controls().autoRotate = false;
    globe.controls().autoRotateSpeed = 0.35;

    // ============================================================================
    // COLOR FUNCTIONS
    // ============================================================================
    function generateColorForFamily(family, index, total) {
      // Generate distinct colors using HSL color space
      const hue = (index * 360 / total) % 360;
      const saturation = 70 + (index % 3) * 10; // 70-90%
      const lightness = 50 + (index % 2) * 10; // 50-60%
      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }
    
    function initializeFamilyColors() {
      const allFamiliesArray = Array.from(state.allFamilies).sort();
      allFamiliesArray.forEach((family, index) => {
        FAMILY_COLORS[family] = generateColorForFamily(family, index, allFamiliesArray.length);
      });
    }
    
    function getColorForFeature(feature) {
      if (state.currentColorMode === COLOR_MODE.FAMILY) {
        return FAMILY_COLORS[feature.Family] || DEFAULT_COLOR;
      }
      // Default mode - all flowers same color
      return DEFAULT_COLOR;
    }

    // ============================================================================
    // CALCULATION FUNCTIONS
    // ============================================================================
    function calculatePointRadius(point) {
      return point.Area * POINT_AREA_SCALE + POINT_BASE_RADIUS;
    }
    
    function calculatePolygonCenter(coordinates) {
      // Take first polygon's first ring
      const ring = coordinates[0][0];
      let latSum = 0;
      let lngSum = 0;
      
      ring.forEach(coord => {
        lngSum += coord[0];
        latSum += coord[1];
      });
      
      const count = ring.length;
      return {
        lat: latSum / count,
        lng: lngSum / count
      };
    }
    
    function createPointFromFeature(feature) {
      const center = calculatePolygonCenter(feature.geometry.coordinates);
      const properties = feature.properties;
      
      return {
        lat: center.lat,
        lng: center.lng,
        Site: `${properties.Family} - ${properties.Genus}`,
        Family: properties.Family,
        Genus: properties.Genus,
        Season: properties.Season,
        Area: properties.Area,
        year: properties.year,
        maxR: properties.Area * RING_AREA_SCALE + RING_BASE_RADIUS,
        propagationSpeed: RING_PROPAGATION_SPEED,
        repeatPeriod: RING_REPEAT_PERIOD
      };
    }

    // ============================================================================
    // UI FUNCTIONS
    // ============================================================================
    function createHexPolygonLabel({ properties: data }) {
      return `
        <b>${data.Family} - ${data.Genus}</b><br/>
        Season: <i>${data.Season}</i><br/>
        Area: <i>${data.Area.toFixed(2)} km²</i><br/>
        Year: <i>${data.year}</i>
      `;
    }
    
    function updateSummary(metadata) {
      console.log('updateSummary called with metadata:', metadata);
      const summaryContent = document.getElementById('summaryContent');
      
      if (!metadata || !metadata.summary) {
        console.log('No summary data in metadata');
        summaryContent.innerHTML = '<p style="color: #7f8c8d; font-style: italic;">No summary data available</p>';
        return;
      }
      
      const summary = metadata.summary;
      console.log('Summary data:', summary);
      let html = '';
      
      // Overview Section
      html += '<h4>📊 Overview</h4>';
      html += `<div class="summary-stat"><span class="label">Total Predictions:</span><span class="value">${summary.total_predictions || 0}</span></div>`;
      html += `<div class="summary-stat"><span class="label">Unique Species:</span><span class="value">${summary.species_count || 0}</span></div>`;
      html += `<div class="summary-stat"><span class="label">Plant Families:</span><span class="value">${summary.family_count || 0}</span></div>`;
      if (summary.total_area) {
        html += `<div class="summary-stat"><span class="label">Total Area:</span><span class="value">${summary.total_area.toLocaleString()} m²</span></div>`;
      }
      
      // Probability Distribution (if available)
      if (summary.average_probability !== undefined) {
        html += '<h4>🎯 Confidence Levels</h4>';
        html += `<div class="summary-stat"><span class="label">Average Probability:</span><span class="value">${(summary.average_probability * 100).toFixed(1)}%</span></div>`;
        
        if (summary.probability_range) {
          html += `<div class="summary-stat"><span class="label">Range:</span><span class="value">${(summary.probability_range.min * 100).toFixed(1)}% - ${(summary.probability_range.max * 100).toFixed(1)}%</span></div>`;
        }
        
        // Confidence bar
        if (summary.high_confidence_count !== undefined) {
          html += '<div class="confidence-bar">';
          if (summary.high_confidence_count > 0) {
            html += `<div class="confidence-segment high-confidence">High: ${summary.high_confidence_count}</div>`;
          }
          if (summary.medium_confidence_count > 0) {
            html += `<div class="confidence-segment medium-confidence">Med: ${summary.medium_confidence_count}</div>`;
          }
          if (summary.low_confidence_count > 0) {
            html += `<div class="confidence-segment low-confidence">Low: ${summary.low_confidence_count}</div>`;
          }
          html += '</div>';
        }
      }
      
      // Seasonal Distribution
      if (summary.seasons && Object.keys(summary.seasons).length > 0) {
        html += '<h4>🌸 Seasonal Distribution</h4>';
        const sortedSeasons = Object.entries(summary.seasons).sort((a, b) => b[1] - a[1]);
        sortedSeasons.forEach(([season, count]) => {
          html += `<div class="summary-stat"><span class="label">${season}:</span><span class="value">${count}</span></div>`;
        });
      }
      
      // Family Distribution (top 5)
      if (summary.families && Object.keys(summary.families).length > 0) {
        html += '<h4>🌿 Top Plant Families</h4>';
        const sortedFamilies = Object.entries(summary.families).sort((a, b) => b[1] - a[1]).slice(0, 5);
        sortedFamilies.forEach(([family, count]) => {
          html += `<div class="summary-stat"><span class="label">${family}:</span><span class="value">${count}</span></div>`;
        });
      }
      
      // Environmental Summary
      if (summary.environmental_summary && Object.keys(summary.environmental_summary).length > 0) {
        html += '<h4>🌡️ Environmental Conditions</h4>';
        const env = summary.environmental_summary;
        
        if (env.temperature) {
          html += `<div class="summary-stat"><span class="label">Temperature (avg):</span><span class="value">${env.temperature.avg}°C</span></div>`;
          html += `<div class="summary-stat"><span class="label">Temp Range:</span><span class="value">${env.temperature.min}°C - ${env.temperature.max}°C</span></div>`;
        }
        
        if (env.precipitation) {
          html += `<div class="summary-stat"><span class="label">Precipitation (avg):</span><span class="value">${env.precipitation.avg} mm</span></div>`;
        }
        
        if (env.vegetation_index) {
          html += `<div class="summary-stat"><span class="label">NDVI (avg):</span><span class="value">${env.vegetation_index.avg}</span></div>`;
        }
      }
      
      // Prediction Info
      if (metadata.prediction_date) {
        html += '<h4>ℹ️ Prediction Info</h4>';
        html += `<div class="summary-stat"><span class="label">Date:</span><span class="value">${metadata.prediction_date}</span></div>`;
        html += `<div class="summary-stat"><span class="label">Model:</span><span class="value">${metadata.model_version || 'N/A'}</span></div>`;
        if (metadata.confidence_threshold) {
          html += `<div class="summary-stat"><span class="label">Threshold:</span><span class="value">${(metadata.confidence_threshold * 100).toFixed(0)}%</span></div>`;
        }
      }
      
      summaryContent.innerHTML = html;
    }
    
    function updateLegend() {
      const legendContent = document.getElementById('legendContent');
      
      if (state.currentColorMode === COLOR_MODE.FAMILY) {
        // Show all families in legend
        const familyCounts = {};
        state.geojsonFeatures.forEach(f => {
          const family = f.properties.Family;
          familyCounts[family] = (familyCounts[family] || 0) + 1;
        });
        
        const sortedFamilies = Object.entries(familyCounts)
          .sort((a, b) => b[1] - a[1])
          .map(([family]) => family);
        
        let html = '<h4 style="margin: 10px 0 8px 0;">Families</h4>';
        sortedFamilies.forEach(family => {
          html += `
            <div class="legend-item">
              <div class="color-box" style="background-color: ${FAMILY_COLORS[family]};"></div>
              <span>${family}</span>
            </div>
          `;
        });
        
        legendContent.innerHTML = html;
      } else {
        // Default mode - no legend needed
        legendContent.innerHTML = '';
      }
    }

    // ============================================================================
    // TIMELINE FUNCTIONS
    // ============================================================================
    function buildTimelineSteps() {
      // Extract unique years from data
      const yearsSet = new Set(state.geojsonFeatures.map(f => f.properties.year));
      state.allYears = Array.from(yearsSet).sort((a, b) => a - b);
      
      // Create timeline steps: each year has 4 seasons
      const seasons = ['Spring', 'Summer', 'Fall', 'Winter'];
      state.timelineSteps = [];
      
      state.allYears.forEach(year => {
        seasons.forEach(season => {
          state.timelineSteps.push({ year, season });
        });
      });
      
      // Update slider max value
      const slider = document.getElementById('timelineSlider');
      slider.max = state.timelineSteps.length - 1;
      
      // Find the index for Spring 2000
      const spring2000Index = state.timelineSteps.findIndex(
        step => step.year === 2000 && step.season === 'Spring'
      );
      
      // Set initial position to Spring 2000, or 0 if not found
      state.currentTimelineIndex = spring2000Index !== -1 ? spring2000Index : 0;
      slider.value = state.currentTimelineIndex;
      
      // Set initial timeline position
      updateTimelineDisplay();
    }
    
    function updateTimelineDisplay() {
      if (state.timelineSteps.length === 0) return;
      
      const currentStep = state.timelineSteps[state.currentTimelineIndex];
      document.getElementById('currentYear').textContent = currentStep.year;
      document.getElementById('currentSeason').textContent = currentStep.season;
      
      // Update slider position
      document.getElementById('timelineSlider').value = state.currentTimelineIndex;
      
      // Update prev/next button states
      document.getElementById('prevBtn').disabled = state.currentTimelineIndex === 0;
      document.getElementById('nextBtn').disabled = state.currentTimelineIndex === state.timelineSteps.length - 1;
      
      // Filter data based on current timeline
      applyTimelineFilter();
    }
    
    function applyTimelineFilter() {
      if (state.timelineSteps.length === 0) return;
      
      const currentStep = state.timelineSteps[state.currentTimelineIndex];
      
      state.filteredFeatures = state.geojsonFeatures.filter(feature => {
        const matchesTimeline = feature.properties.year === currentStep.year && 
                                feature.properties.Season === currentStep.season;
        
        // Apply family and genus filters
        const matchesFamily = state.selectedFamilies.size === 0 || 
                             state.selectedFamilies.has(feature.properties.Family);
        const matchesGenus = state.selectedGenus.size === 0 || 
                            state.selectedGenus.has(feature.properties.Genus);
        
        return matchesTimeline && matchesFamily && matchesGenus;
      });
      
      state.filteredPoints = state.pointsData.filter(point => {
        const matchesTimeline = point.year === currentStep.year && 
                               point.Season === currentStep.season;
        
        // Apply family and genus filters
        const matchesFamily = state.selectedFamilies.size === 0 || 
                             state.selectedFamilies.has(point.Family);
        const matchesGenus = state.selectedGenus.size === 0 || 
                            state.selectedGenus.has(point.Genus);
        
        return matchesTimeline && matchesFamily && matchesGenus;
      });
      
      // Update display
      if (state.currentDisplayMode === DISPLAY_MODE.HEX) {
        switchToHexMode();
      } else {
        switchToPointsMode();
      }
    }
    
    function goToPreviousStep() {
      if (state.currentTimelineIndex > 0) {
        state.currentTimelineIndex--;
        updateTimelineDisplay();
      }
    }
    
    function goToNextStep() {
      if (state.currentTimelineIndex < state.timelineSteps.length - 1) {
        state.currentTimelineIndex++;
        updateTimelineDisplay();
      }
    }
    
    function togglePlayPause() {
      state.isPlaying = !state.isPlaying;
      const playPauseBtn = document.getElementById('playPauseBtn');
      
      if (state.isPlaying) {
        playPauseBtn.textContent = '⏸ Pause';
        state.playInterval = setInterval(() => {
          if (state.currentTimelineIndex < state.timelineSteps.length - 1) {
            goToNextStep();
          } else {
            // Loop back to start
            state.currentTimelineIndex = 0;
            updateTimelineDisplay();
          }
        }, 500); // Change every half second (2x faster)
      } else {
        playPauseBtn.textContent = '▶ Play';
        if (state.playInterval) {
          clearInterval(state.playInterval);
          state.playInterval = null;
        }
      }
    }
    
    function handleSliderChange(event) {
      state.currentTimelineIndex = parseInt(event.target.value);
      updateTimelineDisplay();
      
      // Pause if playing
      if (state.isPlaying) {
        togglePlayPause();
      }
    }

    function createFilterUI() {
      updateFamilyCheckboxes();
      updateGenusCheckboxes();
      
      // Add search listeners
      document.getElementById('familySearch').addEventListener('input', (e) => {
        updateFamilyCheckboxes(e.target.value);
      });
      
      document.getElementById('speciesSearch').addEventListener('input', (e) => {
        updateGenusCheckboxes(e.target.value);
      });
    }
    
    function updateFamilyCheckboxes(searchTerm = '') {
      const container = document.getElementById('familyCheckboxes');
      const families = Array.from(state.allFamilies).sort();
      const filteredFamilies = searchTerm 
        ? families.filter(f => f.toLowerCase().includes(searchTerm.toLowerCase()))
        : families;
      
      // Determine if a family should be checked
      // If selectedFamilies is empty, all should be checked (no filter active)
      // Otherwise, only selected ones should be checked
      const shouldBeChecked = (family) => {
        if (state.selectedFamilies.size === 0) {
          return true; // No filter active, all checked
        }
        return state.selectedFamilies.has(family);
      };
      
      container.innerHTML = filteredFamilies.map(family => `
        <label class="checkbox-item">
          <input type="checkbox" value="${family}" 
                 ${shouldBeChecked(family) ? 'checked' : ''}>
          ${family}
        </label>
      `).join('');
      
      // Add event listeners
      container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', handleFamilyFilterChange);
      });
    }
    
    function updateGenusCheckboxes(searchTerm = '') {
      const container = document.getElementById('genusCheckboxes');
      const genuses = Array.from(state.allGenus).sort();
      const filteredGenuses = searchTerm 
        ? genuses.filter(g => g.toLowerCase().includes(searchTerm.toLowerCase()))
        : genuses;
      
      // Determine if a genus should be checked
      const shouldBeChecked = (genus) => {
        if (state.selectedGenus.size === 0) {
          return true; // No filter active, all checked
        }
        return state.selectedGenus.has(genus);
      };
      
      container.innerHTML = filteredGenuses.map(genus => `
        <label class="checkbox-item">
          <input type="checkbox" value="${genus}" 
                 ${shouldBeChecked(genus) ? 'checked' : ''}>
          ${genus}
        </label>
      `).join('');
      
      // Add event listeners
      container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', handleGenusFilterChange);
      });
    }
    
    function handleFamilyFilterChange(event) {
      const changedFamily = event.target.value;
      const isChecked = event.target.checked;
      const container = document.getElementById('familyCheckboxes');
      const allCheckboxes = container.querySelectorAll('input[type="checkbox"]');
      const checkedCheckboxes = Array.from(allCheckboxes).filter(cb => cb.checked);
      
      // Clear and rebuild the selected set based on what's checked
      state.selectedFamilies.clear();
      checkedCheckboxes.forEach(cb => {
        state.selectedFamilies.add(cb.value);
      });
      
      // If all are checked, clear the set (means show all)
      if (checkedCheckboxes.length === allCheckboxes.length) {
        state.selectedFamilies.clear();
      }
      
      // CASCADE: If a family was unchecked, uncheck all its genus children
      if (!isChecked) {
        // Find all genus that belong to this family
        const genusInFamily = Array.from(state.genusToFamily.entries())
          .filter(([genus, family]) => family === changedFamily)
          .map(([genus, family]) => genus);
        
        // Remove these genus from selected set
        genusInFamily.forEach(genus => {
          state.selectedGenus.delete(genus);
        });
        
        // Update genus checkboxes to reflect the change
        const genusContainer = document.getElementById('genusCheckboxes');
        genusContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
          if (genusInFamily.includes(checkbox.value)) {
            checkbox.checked = false;
          }
        });
      }
      
      applyTimelineFilter();
    }
    
    function handleGenusFilterChange(event) {
      const genus = event.target.value;
      const container = document.getElementById('genusCheckboxes');
      const allCheckboxes = container.querySelectorAll('input[type="checkbox"]');
      const checkedCheckboxes = Array.from(allCheckboxes).filter(cb => cb.checked);
      
      // Clear and rebuild the selected set based on what's checked
      state.selectedGenus.clear();
      checkedCheckboxes.forEach(cb => {
        state.selectedGenus.add(cb.value);
      });
      
      // If all are checked, clear the set (means show all)
      if (checkedCheckboxes.length === allCheckboxes.length) {
        state.selectedGenus.clear();
      }
      
      applyTimelineFilter();
    }

    // ============================================================================
    // DISPLAY MODE FUNCTIONS
    // ============================================================================
    function switchToHexMode() {
      globe.hexPolygonsData(state.filteredFeatures);
      globe.pointsData([]);
      globe.ringsData([]);
      document.getElementById('toggleModeBtn').textContent = 'Switch to Points';
    }
    
    function switchToPointsMode() {
      globe.pointsData(state.filteredPoints);
      globe.hexPolygonsData([]);
      globe.ringsData(state.ringsEnabled ? state.filteredPoints : []);
      document.getElementById('toggleModeBtn').textContent = 'Switch to Hex Polygons';
    }
    
    function refreshGlobeColors() {
      // Force update by resetting data
      globe.hexPolygonsData(globe.hexPolygonsData());
      globe.pointsData(globe.pointsData());
      globe.ringsData(globe.ringsData());
    }

    // ============================================================================
    // CLOUDS FUNCTIONS
    // ============================================================================
    function initializeClouds() {
      new THREE.TextureLoader().load(CLOUDS_IMAGE_URL, cloudsTexture => {
        const cloudsGeometry = new THREE.SphereGeometry(
          globe.getGlobeRadius() * (1 + CLOUDS_ALTITUDE), 
          75, 
          75
        );
        const cloudsMaterial = new THREE.MeshPhongMaterial({ 
          map: cloudsTexture, 
          transparent: true 
        });
        
        state.cloudsMesh = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
        // Clouds are toggled off by default - don't add to scene initially
        // globe.scene().add(state.cloudsMesh);
        
        animateClouds();
      });
    }
    
    function animateClouds() {
      if (state.cloudsMesh) {
        state.cloudsMesh.rotation.y += CLOUDS_ROTATION_SPEED * Math.PI / 180;
      }
      requestAnimationFrame(animateClouds);
    }
    
    function toggleCloudsVisibility() {
      if (!state.cloudsMesh) return;
      
      const scene = globe.scene();
      if (scene.children.includes(state.cloudsMesh)) {
        scene.remove(state.cloudsMesh);
      } else {
        scene.add(state.cloudsMesh);
      }
    }

    // ============================================================================
    // DATA LOADING
    // ============================================================================
    function loadGeoJSONData() {
      // Fetch bloom predictions from API using the v2 model (faster and more reliable than satellite data)
      // Using Querétaro as default since it's been tested and works well
      fetch(`${API_BASE_URL}/predict/blooms?aoi_type=state&aoi_state=Queretaro&date=2025-10-05&method=v2&num_predictions=150`)
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          const allFeatures = data.features.filter(feature => 
            feature.properties.Family && feature.properties.Genus && feature.properties.Season
          );
          state.geojsonFeatures = allFeatures;
          state.pointsData = allFeatures.map(createPointFromFeature);
          
          // Populate all families and genus
          state.allFamilies = new Set(allFeatures.map(f => f.properties.Family));
          state.allGenus = new Set(allFeatures.map(f => f.properties.Genus));
          state.selectedFamilies = new Set(state.allFamilies);
          state.selectedGenus = new Set(state.allGenus);
          
          // Initial filter
          applyFilters();
          
          createFilterUI();
          updateLegend();
          
          // Update summary panel
          if (data.metadata) {
            console.log('Updating summary with metadata:', data.metadata);
            updateSummary(data.metadata);
            // Auto-show summary panel when data loads
            document.getElementById('summary').style.display = 'block';
            document.getElementById('toggleSummaryBtn').textContent = 'Hide Summary';
          } else {
            console.log('No metadata in response');
          }
        })
        .catch(error => {
          console.error('Error loading bloom data from API:', error);
          // Fallback to static files if API fails
          console.log('Falling back to static GeoJSON files...');
          loadStaticGeoJSON();
        });
    }

    function loadStaticGeoJSON() {
      Promise.all(GEOJSON_FILES.map(file => fetch(file).then(response => response.json())))
        .then(datas => {
          const allFeatures = datas.flatMap(data => data.features).filter(feature => 
            feature.properties.Family && feature.properties.Genus && feature.properties.Season
          );
          state.geojsonFeatures = allFeatures;
          state.pointsData = allFeatures.map(createPointFromFeature);
          
          // Populate all families and genus
          state.allFamilies = new Set(allFeatures.map(f => f.properties.Family));
          state.allGenus = new Set(allFeatures.map(f => f.properties.Genus));
          
          // Build genus to family mapping
          state.genusToFamily.clear();
          allFeatures.forEach(f => {
            state.genusToFamily.set(f.properties.Genus, f.properties.Family);
          });
          
          // Initialize family colors
          initializeFamilyColors();
          
          // Build timeline
          buildTimelineSteps();
          
          // Create filter UI
          createFilterUI();
          
          updateLegend();
          switchToPointsMode();
        })
        .catch(error => {
          console.error('Error loading GeoJSON data:', error);
          alert('Error loading data: ' + error.message);
        });
    }

    // ============================================================================
    // FILTERING FUNCTIONS (Legacy - now handled by timeline)
    // ============================================================================
    function applyFilters() {
      // Now handled by applyTimelineFilter
      applyTimelineFilter();
    }

    // ============================================================================
    // EVENT HANDLERS
    // ============================================================================
    function handleToggleModeClick() {
      if (state.currentDisplayMode === DISPLAY_MODE.HEX) {
        state.currentDisplayMode = DISPLAY_MODE.POINTS;
        switchToPointsMode();
      } else {
        state.currentDisplayMode = DISPLAY_MODE.HEX;
        switchToHexMode();
      }
      refreshGlobeColors();
    }
    
    function handleToggleRingsClick() {
      state.ringsEnabled = !state.ringsEnabled;
      if (state.currentDisplayMode === DISPLAY_MODE.POINTS) {
        globe.ringsData(state.ringsEnabled ? state.filteredPoints : []);
        refreshGlobeColors();
      }
    }
    
    function handleToggleColorClick() {
      // Toggle between default and family color modes
      if (state.currentColorMode === COLOR_MODE.DEFAULT) {
        state.currentColorMode = COLOR_MODE.FAMILY;
        document.getElementById('toggleColorBtn').textContent = 'Single Color';
      } else {
        state.currentColorMode = COLOR_MODE.DEFAULT;
        document.getElementById('toggleColorBtn').textContent = 'Color by Family';
      }
      
      // Update legend
      updateLegend();
      
      // Refresh globe colors
      refreshGlobeColors();
    }

    // ============================================================================
    // EVENT LISTENERS
    // ============================================================================
    document.getElementById('toggleCloudsBtn').addEventListener('click', toggleCloudsVisibility);
    document.getElementById('toggleRingsBtn').addEventListener('click', handleToggleRingsClick);
    document.getElementById('toggleModeBtn').addEventListener('click', handleToggleModeClick);
    document.getElementById('toggleColorBtn').addEventListener('click', handleToggleColorClick);
    
    // Toggle summary button
    document.getElementById('toggleSummaryBtn').addEventListener('click', function() {
      const summaryPanel = document.getElementById('summary');
      const toggleBtn = document.getElementById('toggleSummaryBtn');
      
      if (summaryPanel.style.display === 'none' || summaryPanel.style.display === '') {
        summaryPanel.style.display = 'block';
        toggleBtn.textContent = 'Hide Summary';
      } else {
        summaryPanel.style.display = 'none';
        toggleBtn.textContent = 'Show Summary';
      }
    });
    
    // Data source selection
    document.getElementById('dataSourceSelect').addEventListener('change', function(e) {
      const predictionOptions = document.getElementById('predictionOptions');
      predictionOptions.style.display = e.target.value === 'prediction' ? 'block' : 'none';
    });
    
    // AOI Type selection - show/hide relevant options
    document.getElementById('aoiTypeSelect').addEventListener('change', function(e) {
      const aoiType = e.target.value;
      document.getElementById('pointCoordinates').style.display = aoiType === 'point' ? 'block' : 'none';
      document.getElementById('countryOptions').style.display = aoiType === 'country' ? 'block' : 'none';
      document.getElementById('stateOptions').style.display = aoiType === 'state' ? 'block' : 'none';
    });
    
    // Filter listeners
    document.getElementById('seasonCheckboxes').addEventListener('change', handleSeasonCheckboxChange);
    document.getElementById('applyAoiBtn').addEventListener('click', function() {
      const aoiType = document.getElementById('aoiTypeSelect').value;
      const date = document.getElementById('dateInput').value;
      const dataSource = document.getElementById('dataSourceSelect').value;
      const confidence = document.getElementById('confidenceInput').value;
      const numPredictions = document.getElementById('numPredictionsInput').value;

      console.log('AOI Button clicked:', { aoiType, date, dataSource });

      // Build query string based on AOI type
      const params = {
        aoi_type: aoiType,
        date: date
      };
      
      // Add type-specific parameters
      if (aoiType === 'point') {
        const lat = document.getElementById('latInput').value;
        const lon = document.getElementById('lonInput').value;
        if (!lat || !lon) {
          alert('Please enter latitude and longitude for point location');
          return;
        }
        params.lat = lat;
        params.lon = lon;
      } else if (aoiType === 'state') {
        const stateCountry = document.getElementById('stateCountrySelect').value;
        const aoiState = document.getElementById('aoiStateSelect').value;
        if (!aoiState) {
          alert('Please select a state');
          return;
        }
        params.aoi_country = stateCountry;
        params.aoi_state = aoiState;
      } else if (aoiType === 'country') {
        const aoiCountry = document.getElementById('aoiCountrySelect').value;
        if (!aoiCountry) {
          alert('Please select a country');
          return;
        }
        params.aoi_country = aoiCountry;
      }
      
      // Add prediction-specific parameters
      if (dataSource === 'prediction') {
        params.method = 'v2';
        params.confidence = confidence;
        params.num_predictions = numPredictions;
      }
      
      const qs = new URLSearchParams(params).toString();
      
      // Choose endpoint based on data source
      const endpoint = dataSource === 'prediction' ? 'predict/blooms' : 'data/blooms';
      const apiUrl = `${API_BASE_URL}/${endpoint}?${qs}`;
      console.log('Fetching from:', apiUrl);

      // Show loading indicator
      const btn = document.getElementById('applyAoiBtn');
      const originalText = btn.textContent;
      btn.textContent = '⏳ Loading...';
      btn.disabled = true;

      fetch(apiUrl)
        .then(r => {
          console.log('API Response status:', r.status);
          if (!r.ok) {
            throw new Error(`API returned status ${r.status}`);
          }
          return r.json();
        })
        .then(data => {
          console.log('API Response data:', data);
          console.log('Number of features:', data.features ? data.features.length : 0);
          console.log('Metadata:', data.metadata);

          const allFeatures = (data.features || []).filter(feature => {
            const hasProps = feature.properties && feature.properties.Family && feature.properties.Genus && feature.properties.Season;
            return hasProps;
          });

          console.log('Filtered features count:', allFeatures.length);

          if (allFeatures.length === 0) {
            alert('No bloom data found for the selected area and date. Try a different location or date.');
            return;
          }

          state.geojsonFeatures = allFeatures;
          state.pointsData = allFeatures.map(createPointFromFeature);
          state.allFamilies = new Set(allFeatures.map(f => f.properties.Family));
          state.allGenus = new Set(allFeatures.map(f => f.properties.Genus));
          state.selectedFamilies = new Set(state.allFamilies);
          state.selectedGenus = new Set(state.allGenus);

          console.log('Updating globe with features...');
          applyFilters();
          createFilterUI();
          
          // Update summary panel
          if (data.metadata) {
            console.log('Updating summary with metadata:', data.metadata);
            updateSummary(data.metadata);
            // Auto-show summary panel when data loads
            document.getElementById('summary').style.display = 'block';
            document.getElementById('toggleSummaryBtn').textContent = 'Hide Summary';
          } else {
            console.log('No metadata in response');
          }

          console.log('Globe update complete');
          alert(`✅ Loaded ${allFeatures.length} bloom predictions!`);
        })
        .catch(err => {
          console.error('AOI fetch failed:', err);
          alert('Error loading data: ' + err.message + '\n\nTrying fallback data...');
          loadStaticGeoJSON();
        })
        .finally(() => {
          // Restore button
          btn.textContent = originalText;
          btn.disabled = false;
        });
    });
    
    // Timeline listeners
    document.getElementById('prevBtn').addEventListener('click', goToPreviousStep);
    document.getElementById('nextBtn').addEventListener('click', goToNextStep);
    document.getElementById('playPauseBtn').addEventListener('click', togglePlayPause);
    document.getElementById('timelineSlider').addEventListener('input', handleSliderChange);

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    loadGeoJSONData();
    initializeClouds();
  </script>
</body>
</html>